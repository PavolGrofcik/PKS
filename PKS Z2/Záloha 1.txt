#include <stdio.h>
#include <winsock2.h>
#include <Ws2def.h>
#include <Ws2tcpip.h>
#include <stdbool.h>
#include <stdlib.h>


#pragma comment(lib,"ws2_32.lib")	//Winsock Library

#define TRUE 1
#define IPLEN 16					//Dĺžka IP adresy
#define BUFFLEN 100000				//Max veľkosť bufferu
#define FRAGMENT_SIZE 1500			//Veľkosť fragmentu
#define ESTABLISHED 2				//Status pre nadviazanie spojenia
#define OFF1		3				//OFFSET 1
#define LOCALHOST "127.0.0.1"		//Localhost

//Hlavička
typedef struct header {
	unsigned long long header_info;


	char *data;
	unsigned int crc32;
}Header;


//Funkcia zobrazí úvodný interface s choices
void user_interface() {

	for (int i = 0; i < 30; i++) {
		putchar('#');
	}
	putchar('\n');
	printf("#\tVitajte v programe   #\n");
	printf("#\tZadajte moznost\t     #\n");
	printf("#\t 1 - client\t\     #\n");
	printf("#\t 2 - server\t     #\n");
	printf("#\t 3 - koniec\t     #\n");

	for (int i = 0; i < 30; i++) {
		putchar('#');
	}
	putchar('\n');
}

//Funkcia slúži na extrakciu dát
unsigned short extract(unsigned short value, int begin, int end)
{
	unsigned short mask = (1 << (end - begin)) - 1;
	return (value >> begin) & mask;
}

//Funkcia inicializuje veľkosť init segmentu
char* handshake(int frag_size) {
	char *new = (char*)malloc(sizeof(Header) + ESTABLISHED + 1);

	if (!new) {
		return NULL;
	}
	else {
		return new;
	}
}

//Funkcia pre server a jeho všetky komponenty
void server() {
	SOCKET s;
	struct sockaddr_in server_in, si_other;

	int recv_len, slen, port,
		status,
		si_other_len,
		attempts = 3,
		mesg_status;
	char buff[BUFFLEN];

	Header *header = NULL;

	//Vytvorenie socketu
	s = socket(AF_INET, SOCK_DGRAM, 0);

	if (s == -1) {
		printf("Nepodarilo sa inicializovat socket\n");
		return -1;
	}

	//Úvodné menu pre server so zadaním portu
	printf("Vitajte v rezime server\n");
	printf("Zadajte port\n");
	scanf("%d", &port);

	if (port < 0 || port < 1023) {
		printf("Zadali ste well know ports. Error\n");
		return -2;
	}

	server_in.sin_family = AF_INET;
	server_in.sin_addr.s_addr = INADDR_ANY;
	server_in.sin_port = htons(port);

	//Nabinodovanie socketu podľa zadaného portu
	if (bind(s, (struct sockaddr*) &server_in, sizeof(server_in)) == SOCKET_ERROR) {
		printf("Neuspesna inicializiacia servera\n");
		closesocket(s);
		return -3;
	}
	else {
		printf("Uspesna inicializacia servera\n");
	}

	/*if (inet_pton(AF_INET, ip, &server_in.sin_addr) == 0) {
		printf("Neuspesne vytvorenie socketu s danou IP %s\n", ip);
		return;
	}*/

	//Listening relácie medzi klientom
	si_other_len = sizeof(si_other);

	while (TRUE) {

		memset(buff, '\0', BUFFLEN);
		//Čakanie na spojenie s klientom
		if ((status = recvfrom(s, buff, BUFFLEN, 0, (struct sockaddr*) &si_other, &si_other_len)) == SOCKET_ERROR) {
			printf("Neuspesny receive\n");
			return -4;
		}
		//Pretypovanie  na hlavičku
		header = (Header*)buff;

		printf("Received packet from %s:%d\n", inet_ntoa(si_other.sin_addr), si_other.sin_port);


		//Kontrolný výpis
		mesg_status = header->header_info & 7;
		printf("Message status is %d\n", mesg_status);

		//Ak bolo požiadanie o ukončenie spojenia
		if (mesg_status == 0) {
			printf("Poziadanie o ukoncenie relacie\n");
			closesocket(s);

			return;
		}
	}


	//Uzavretie socketu po skončení relácie
	closesocket(s);
}


//Funkcia na inicializáciu klienta a jeho komponentov
void client(){

	int s, damaged,
		attempts = 3,
		port,
		frag_len,
		choice;

	struct sockaddr_in client_in, si_other;
	char buff[BUFFLEN],
		ip[IPLEN],
		*message = NULL,
		*init_msg = NULL,
		*datagram = NULL;

	//Header na odosielanie dát
	Header *header = NULL;

	//Vytvorenie socketu
	s = socket(AF_INET, SOCK_DGRAM, 0);

	if (s == -1) {
		printf("Nepodarilo sa inicializovat socket\n");
		return -1;
	}

	//Úvodné okno pre klienta
	printf("Vitajte v rezime klienta\n");
	printf("Zadajte port\n");
	scanf("%d", &port);
	printf("Zadajte IP adresu servera\n");
	printf("Pre LocalHost -> 'LH'\n");
	scanf("%s", ip);

	if (!strcmp(ip, "LH")) {
		strcpy(ip, LOCALHOST);
	}

	//Zadanie veľkosti fragmentu
	while (attempts) {
		printf("Zadajte velkost fragmentu\n");
		scanf("%d", &frag_len);

		//Ošetrenie či klient zadal správnu veľkost fragmentu
		if (frag_len<= 0 || frag_len >= FRAGMENT_SIZE) {
			printf("Nespravna velkost\n");
			printf("Zadajte znovu\n");
			attempts--;

			if (attempts == 0) {
				printf("Nespravne zvolena velkost fragmentu\n");
				printf("Programu bude ukonceny\n");
				return -2;
			}

			continue;
		}
		else {
			break;
		}
	}

	client_in.sin_family = AF_INET;
	client_in.sin_port = htons(port);

	//Nabindovanie socketu podľa zadanej IP
	if (inet_pton(AF_INET, ip, &client_in.sin_addr) == 0) {
		printf("Neuspesne vytvorenie socketu s danou IP %s\n", ip);
		return -3;
	}
	
	//Vytvorenie init segmentu pri nadviazaní spojenia
	init_msg = handshake(frag_len);

	if (!init_msg) {
		printf("Inicializacia spravy zlyhala\n");
		return -4;
	}

	header = (Header*)init_msg;

	//Zakódovanie základných informácií

	//Posun o 3 bity !!!
	header->header_info = 1;
	header->header_info += frag_len<<3;

	printf("Zakodovane je %d\n", extract(header->header_info, 3, 19));
	//Naviazanie relácie medzi serverom
	while (TRUE) {

		//Načítanie správy
		printf("Zadajte 0 - odhlasenie klienta\n");
		printf("Zadajte 1 - odoslanie spravy\n");
		printf("Zadajte 2 - odoslanie chybneho datagramu\n");
		printf("Zadajte 3 - odoslanie suboru\n");
		scanf("%d", &choice);

		//Odhlasenie klienta
		if (choice == 0) {
			//Klient sa chce odhlásiť

			header->header_info = 0;	//Ukončenie spojenia

			if (sendto(s, (char*)header, sizeof(header), 0, (struct sockaddr*) &client_in, sizeof(client_in)) == SOCKET_ERROR) {
				printf("Nepodarilo sa odoslat ukoncenie spojenia\n");
			}

			closesocket(s);
			return;
		}

		//Načítanie správy alebo chybného paketu
		/*if (choice == 1 || choice == 2) {
			printf("Zadajte spravu\n");
			getc(stdin);
			printf("Na koniec zadajte 2x Enter\n");

			message = message_allocation(FRAGOFFSET);

			while (TRUE) {

				fgets(buff, LINE_LEN, stdin);
				if (buff[0] == 0 || buff[1] == 0) {
					break;
				}

				//Preokopírovanie správ do datagramu
				for (int i = 0; i < FRAGOFFSET; i++) {

					if (counter == sizeof(buff)) {
						break;
					}

					if (message[i] == 0) {
						message[i] = buff[counter];
						counter++;
					}
				}

			}

			printf("Sprava je %s\n", message);
		}*/

	}

	//Uzavretie socketu po skončení relácie
	closesocket(s);
}

int main(void){
	int choice = 0,
	attempts = 3;

	//Winsock inicializácia
	WSADATA datad;

	if (WSAStartup(MAKEWORD(2, 2), &datad) != 0) {
		printf("Winsock inicializacia neuspesna\n");
		return -1;
	}

	//Úvodné menu
	user_interface();

	//Hlavný flow 
	while (attempts) {

		scanf("%d", &choice);


		if (choice != 1 && choice != 2 && choice != 3) {
			printf("Nespravny zadany argument\n");
			attempts--;

			if (attempts == 0) {
				printf("Program bude ukonceny\n");
				break;
			}
			continue;
		}

		//Spustenie v režime klienta
		if (choice == 1) {
			client();

		}//Server režim
		else if (choice == 2) {
			server();
		}
		else if (choice == 3) {
			printf("Program bude ukonceny\n");
			return -1;
		}

		user_interface();

	}
}

/*
#define BUFLEN 200000  //Max length of buffer
//#define PORT 8888   //The port on which to listen for incoming data
//#define SERVER "127.0.0.1"  //ip address of udp server

typedef struct Header {
	unsigned crc;
	int info;
	int poradie;
	int velkost;
}Header;


char SERVER[15] = "";
unsigned int PORT = 0;
int velkostF = 0;
int velkostPrijmacieho = 0;

bool prijataVelkost = false;




char *appendMessage(char *buf, char *message, int size) {
	int len = strlen(message);
	char *tmp = (char*)malloc((len + size + 1) * sizeof(char));

	strncpy(tmp, message, len);
	memcpy(tmp + len, buf + sizeof(Header), size);
	tmp[len + size] = '\0';
	free(message);
	return tmp;

}

//https://stackoverflow.com/questions/15169387/definitive-crc-for-c
unsigned crc(unsigned char const *data, int len)
{
	unsigned crc = 0;
	if (data == NULL)
		return 0;
	crc = ~crc & 0xff;
	while (len--) {
		crc ^= *data++;
		for (unsigned k = 0; k < 8; k++)
			crc = crc & 1 ? (crc >> 1) ^ 0xb2 : crc >> 1;
	}
	return crc ^ 0xff;
}

void *server(void *arg)
{
	SOCKET s;
	struct sockaddr_in server, si_other;
	int slen, recv_len;
	char buf[BUFLEN];
	WSADATA wsa;
	char vysledny[99999];
	int vysledna = 0;
	Header *header = NULL;


	slen = sizeof(si_other);

	char *message = (char*)malloc(10);
	message[0] = '\0';

	//Initialise winsock
	printf("\nInitialising Winsock...");
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		printf("Failed. Error Code : %d", WSAGetLastError());
		exit(EXIT_FAILURE);
	}
	printf("Initialised.\n");

	//Create a socket
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d", WSAGetLastError());
	}
	printf("Socket created.\n");

	//Prepare the sockaddr_in structure
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons(PORT);

	//Bind
	if (bind(s, (struct sockaddr *)&server, sizeof(server)) == SOCKET_ERROR)
	{
		printf("Bind failed with error code : %d", WSAGetLastError());
		exit(EXIT_FAILURE);
	}
	puts("Bind done");

	//keep listening for data
	while (1)
	{
		//printf("Waiting for data...\n");
		//fflush(stdout);

		//clear the buffer by filling null, it might have previously received data
		memset(buf, '\0', BUFLEN);

		//try to receive some data, this is a blocking call
		if ((recv_len = recvfrom(s, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen)) == SOCKET_ERROR)
		{
			printf("recvfrom() failed with error code : %d", WSAGetLastError());
			exit(EXIT_FAILURE);
		}

		//print details of the client/peer and the data received

		//printf("Received packet from %s:%d\n", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port));
		header = (Header*)buf;


		unsigned testcrc;

		testcrc = crc(((const unsigned char*)header) + sizeof(unsigned), header->velkost + sizeof(Header) - sizeof(unsigned));
		if (testcrc != header->crc) {
			//printf("s CRC FAILED %d ... %d... %d... %d - %s %d\n", header->crc, header->info, header->poradie, header->velkost, buf, recv_len);

			Header err;
			err.info = 3;
			err.poradie = 0;
			err.velkost = 0;
			err.crc = crc(((const unsigned char*)&err) + sizeof(unsigned), sizeof(Header) - sizeof(unsigned));


			if (sendto(s, (char*)&err, sizeof(Header), 0, (struct sockaddr *) &si_other, slen) == SOCKET_ERROR)
			{
				printf("sendto() failed with error code : %d", WSAGetLastError());
				exit(EXIT_FAILURE);
			}
			continue;
		}
		//printf("s wtf %d ... %d... %d... %d - %c %d\n", header->crc, header->info, header->poradie, header->velkost, buf[sizeof(Header)], recv_len);

		if (header->info == 1 || header->info == 2) {
			message = appendMessage(buf, message, header->velkost);
			//printf("message: %s\n", message);
		}

		if (header->info == 2) { printf("Message full: %s \n", message); message[0] = '\0'; }



		Header conf;
		conf.info = 4;
		if (header->info == 8) {
			conf.info = 9;
			
		}
		conf.poradie = 0;
		conf.velkost = 0;
		conf.crc = crc(((const unsigned char*)&conf) + sizeof(unsigned), sizeof(Header) - sizeof(unsigned));

		//now reply the client with the same data
		if (sendto(s, (char*)&conf, sizeof(Header), 0, (struct sockaddr*) &si_other, slen) == SOCKET_ERROR)
		{
			printf("sendto() failed with error code : %d", WSAGetLastError());
			exit(EXIT_FAILURE);
		}
		if (header->info == 8) { printf("Spojenie bolo ukoncene\n"); break; }
	}

	closesocket(s);
	WSACleanup();

	return 0;
}

void *klient(void *arg)
{
	Header *header = NULL;
	struct sockaddr_in si_other;
	int s, slen = sizeof(si_other);
	char buf[BUFLEN];
	char message[BUFLEN];
	char *packet;
	char *posielany;
	bool chyba = false;

	WSADATA wsa;

	//Initialise winsock
	printf("\nInitialising Winsock...");
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		printf("Failed. Error Code : %d", WSAGetLastError());
		exit(EXIT_FAILURE);
	}
	printf("Initialised.\n");

	//create socket
	if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR)
	{
		printf("socket() failed with error code : %d", WSAGetLastError());
		exit(EXIT_FAILURE);
	}

	//setup address structure
	memset((char *)&si_other, 0, sizeof(si_other));
	si_other.sin_family = AF_INET;
	si_other.sin_port = htons(PORT);
	si_other.sin_addr.S_un.S_addr = inet_addr(SERVER);

	//start communication


	//Treba ošetriť podľa veľkosti fragmentu 1514 Bytes on Link layer
	//Prerobiť
	printf("Zadaj velkost fragmentu:");
	gets_s(message,1500);
	posielany = (char*)malloc((atoi(message) + sizeof(Header) + 1) * sizeof(char));
	header = (Header*)posielany;
	header->velkost = atoi(message);

	//packet = (char*)malloc((header->velkost + 1) * sizeof(char));


	while (1)
	{
		printf("Enter message : ");

		gets_s(message, BUFLEN);
		//header->velkost = strlen(message);
		header->poradie = 0;

		if ((strcmp(message, "quit") == 0)) {

			Header q;
			q.info = 8;
			q.poradie = 0;
			q.velkost = 0;
			q.crc = crc(((const unsigned char*)&q) + sizeof(unsigned), sizeof(Header) - sizeof(unsigned));
			if (sendto(s, (char*)&q, sizeof(Header), 0, (struct sockaddr *) &si_other, slen) == SOCKET_ERROR)
			{
				printf("sendto() failed with error code : %d", WSAGetLastError());
				exit(EXIT_FAILURE);
			}


			break;
		}
		if ((strcmp(message, "chyba") == 0)) {
			chyba = true;
			continue;
		}
		int poslane = 0;
		int dlzka;
		//int crc1 = 0, crc2 = 0;

		dlzka = strlen(message);

		while (dlzka > 0) {


			if (dlzka <= header->velkost) {
				header->info = 2;
			}
			else header->info = 1;

			header->poradie++;


			memcpy(posielany + sizeof(Header), message + ((header->poradie - 1) * header->velkost), min(header->velkost, dlzka + 1));


			dlzka -= header->velkost;
		sem:
			header->crc = crc(((const unsigned char*)posielany) + sizeof(unsigned), header->velkost + sizeof(Header) - sizeof(unsigned));

			if (chyba == true && dlzka <= header->velkost) { header->crc++; chyba = false; }

			//printf("k %d ... %d... %d... %d ... %c\n", header->crc, header->info, header->poradie, header->velkost, posielany[sizeof(Header)]);
			//printf("k %d ... %d... %d... %d - %c %d\n", header->crc, header->info, header->poradie, header->velkost, posielany[sizeof(Header)], header->velkost + sizeof(Header));
			//send the message
			if (sendto(s, posielany, header->velkost + sizeof(Header), 0, (struct sockaddr *) &si_other, slen) == SOCKET_ERROR)
			{
				printf("sendto() failed with error code : %d", WSAGetLastError());
				exit(EXIT_FAILURE);
			}
			fd_set fds;
			int n;
			struct timeval tv;

			// Set up the file descriptor set.
			FD_ZERO(&fds);
			FD_SET(s, &fds);

			// Set up the struct timeval for the timeout.
			tv.tv_sec = 5;
			tv.tv_usec = 0;

			// Wait until timeout or data received.
			n = select(s, &fds, NULL, NULL, &tv);
			if (n == 0)
			{
				printf("Timeout..\n");
				goto sem;
			}
			else if (n == -1)
			{
				printf("Error..\n");
				return 0;
			}

			//receive a reply and print it
			//clear the buffer by filling null, it might have previously received data
			memset(buf, '\0', BUFLEN);
			//try to receive some data, this is a blocking call
			if (recvfrom(s, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen) == SOCKET_ERROR)
			{
				printf("recvfrom() failed with error code : %d", WSAGetLastError());
				exit(EXIT_FAILURE);
			}
		tu:
			Header* h = (Header*)buf;
			if (h->info == 3) {
				printf("vyziadany resend! cislo ramca: %d\n", header->poradie);
				goto sem;

			}

			//puts(buf);

		}
	}

	closesocket(s);
	WSACleanup();

	return 0;
}


int main()
{
	
	time_t start, end;
	 long double counter = 100000;

	//printf("Zadaj velkost fragmentu:");
	//scanf("%d", &velkostF);
	//pthread_t klientVlakno, serverVlakno;

	while (1) {
		printf("Pre server zadaj 1\n");
		printf("Pre klient zadaj 2\n");
		char a;
		if ((a = getchar()) == '1') {
			getchar();
			printf("\n");
			printf("Zadaj port:");
			scanf("%d", &PORT);
			getchar();
			server(NULL);

		}
		if (a == '2') {
			getchar();
			printf("\n");
			printf("Zadaj IP adresu prijimatela:");
			scanf("%s", &SERVER);
			printf("Zadaj port:");
			scanf("%d", &PORT);
			getchar();
			klient(NULL);
		}

	}


	 //11 s keep alive
	start = clock();
	while (counter > 0) {

		counter--;
		printf("%Lf\n", counter);
	}
	end = clock();

	printf("Elapsed time %d s\n", (end - start) / 1000);
	
	return 0;
};*/